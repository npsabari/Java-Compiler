//
// Generated by JTB 1.3.2
//

package visitor;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;


import syntaxtree.BinOp;
import syntaxtree.CJumpStmt;
import syntaxtree.Call;
import syntaxtree.ErrorStmt;
import syntaxtree.Exp;
import syntaxtree.Goal;
import syntaxtree.HAllocate;
import syntaxtree.HLoadStmt;
import syntaxtree.HStoreStmt;
import syntaxtree.IntegerLiteral;
import syntaxtree.JumpStmt;
import syntaxtree.Label;
import syntaxtree.MoveStmt;
import syntaxtree.NoOpStmt;
import syntaxtree.Node;
import syntaxtree.NodeList;
import syntaxtree.NodeListOptional;
import syntaxtree.NodeOptional;
import syntaxtree.NodeSequence;
import syntaxtree.NodeToken;
import syntaxtree.Operator;
import syntaxtree.PrintStmt;
import syntaxtree.Procedure;
import syntaxtree.SimpleExp;
import syntaxtree.Stmt;
import syntaxtree.StmtExp;
import syntaxtree.StmtList;
import syntaxtree.Temp;
import dataStructures.BasicBlock;
import dataStructures.ProcedureClass;
import dataStructures.TempClass;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class ConstructCFG<R> implements GJNoArguVisitor<R> {
	private ProcedureClass curProcedure = null;
	private BasicBlock curBasicBlock = null, prevBlock = null;
	
	private HashMap<String, ArrayList<BasicBlock>> toBefilled = new HashMap<String, ArrayList<BasicBlock>>();
	public static HashMap<String, BasicBlock> labelSeen = new HashMap<String, BasicBlock>();
	private HashMap<Integer, TempClass> tempMap = new HashMap<Integer, TempClass>();
	
	public static ArrayList<TempClass> tempSeen = new ArrayList<TempClass>();
	public static ArrayList<ProcedureClass> procList = new ArrayList<ProcedureClass>();
	public static HashMap<String, ProcedureClass> procMap = new HashMap<String, ProcedureClass>();
	
	private int lineNum = 0;
	private String label = null;
	private boolean use = false;
	
	
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() ){
    	  R _ret = n.node.accept(this);
    	  ++lineNum;
    	  BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
          curBasicBlock = tmpBasicBlock;
          curProcedure.stmtLst.add(tmpBasicBlock);
    	  if(toBefilled.containsKey(label)){
    		  for( BasicBlock i : toBefilled.get(label)){
    			  i.successors.add(tmpBasicBlock);
    			  tmpBasicBlock.predecessors.add(i);
    		  }
    		  toBefilled.remove(label);
    	  }
    	  labelSeen.put(label, tmpBasicBlock);
    	  if(prevBlock != null){
    		  tmpBasicBlock.predecessors.add(prevBlock);
    		  
    		  prevBlock.successors.add(tmpBasicBlock);
    	  }
    	  prevBlock = tmpBasicBlock;
    	  return _ret;
      }
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n) {
      R _ret=null;
      ++lineNum;
      n.f0.accept(this);
      ProcedureClass tmpProcedure = new ProcedureClass("MAIN", 0, lineNum);
      procList.add(tmpProcedure);
      curProcedure = tmpProcedure;
      procMap.put("MAIN", tmpProcedure);
      n.f1.accept(this);
      ++lineNum;
      n.f2.accept(this);
      tmpProcedure.lineEnd = lineNum;
      curProcedure = null;
      n.f3.accept(this);
      ++lineNum;
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n) {
      R _ret=null;
      ++lineNum;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      ProcedureClass tmpProcedure = new ProcedureClass(n.f0.f0.tokenImage, Integer.parseInt(n.f2.f0.tokenImage), lineNum);
      procList.add(tmpProcedure);
      curProcedure = tmpProcedure;
      procMap.put(tmpProcedure.name, tmpProcedure);
      tempMap.clear();
      n.f4.accept(this);
      curProcedure.lineEnd = lineNum;
      curProcedure = null;
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n) {
      R _ret=null;
      ++lineNum;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n) {
      R _ret=null;
      BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
      curBasicBlock = tmpBasicBlock;
      curProcedure.stmtLst.add(tmpBasicBlock);
      if(prevBlock != null){
		  tmpBasicBlock.predecessors.add(prevBlock);
		  prevBlock.successors.add(tmpBasicBlock);
	  }
      n.f0.accept(this);
      prevBlock = tmpBasicBlock;
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n) {
      R _ret=null;
      BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
      curBasicBlock = tmpBasicBlock;
      curProcedure.stmtLst.add(tmpBasicBlock);
      if(prevBlock != null){
		  tmpBasicBlock.predecessors.add(prevBlock);
		  prevBlock.successors.add(tmpBasicBlock);
	  }
      n.f0.accept(this);
      prevBlock = tmpBasicBlock;
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n) {
      R _ret=null;
      BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
      curBasicBlock = tmpBasicBlock;
      curProcedure.stmtLst.add(tmpBasicBlock);
      if(prevBlock != null){
		  tmpBasicBlock.predecessors.add(prevBlock);
		  prevBlock.successors.add(tmpBasicBlock);
	  }
      n.f0.accept(this);
      use = true;
      n.f1.accept(this);
      n.f2.accept(this);
      if(labelSeen.containsKey(label)){
    	  tmpBasicBlock.successors.add(labelSeen.get(label));
    	  labelSeen.get(label).predecessors.add(tmpBasicBlock);
      }
      else{
    	  if(toBefilled.containsKey(label)){
    		  toBefilled.get(label).add(tmpBasicBlock);
    	  }
    	  else{
    		  toBefilled.put(label, new ArrayList<BasicBlock>());
    		  toBefilled.get(label).add(tmpBasicBlock);
    	  }
      }
      prevBlock = tmpBasicBlock;
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n) {
      R _ret=null;
      BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
      curBasicBlock = tmpBasicBlock;
      curProcedure.stmtLst.add(tmpBasicBlock);
      if(prevBlock != null){
		  tmpBasicBlock.predecessors.add(prevBlock);
		  prevBlock.successors.add(tmpBasicBlock);
	  }
      n.f0.accept(this);
      n.f1.accept(this);
      if(labelSeen.containsKey(label)){
    	  tmpBasicBlock.successors.add(labelSeen.get(label));
    	  labelSeen.get(label).predecessors.add(tmpBasicBlock);
      }
      else{
    	  if(toBefilled.containsKey(label)){
    		  toBefilled.get(label).add(tmpBasicBlock);
    	  }
    	  else{
    		  toBefilled.put(label, new ArrayList<BasicBlock>());
    		  toBefilled.get(label).add(tmpBasicBlock);
    	  }
      }
      prevBlock = null;
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n) {
      R _ret=null;
      BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
      curBasicBlock = tmpBasicBlock;
      curProcedure.stmtLst.add(tmpBasicBlock);
      if(prevBlock != null){
		  tmpBasicBlock.predecessors.add(prevBlock);
		  prevBlock.successors.add(tmpBasicBlock);
	  }
      n.f0.accept(this);
      use = true;
      n.f1.accept(this);
      n.f2.accept(this);
      use = true;
      n.f3.accept(this);
      prevBlock = tmpBasicBlock;
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n) {
      R _ret=null;
      BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
      curBasicBlock = tmpBasicBlock;
      curProcedure.stmtLst.add(tmpBasicBlock);
      if(prevBlock != null){
		  tmpBasicBlock.predecessors.add(prevBlock);
		  prevBlock.successors.add(tmpBasicBlock);
	  }
      n.f0.accept(this);
      use = false;
      n.f1.accept(this);
      use = true;
      n.f2.accept(this);
      n.f3.accept(this);
      prevBlock = tmpBasicBlock;
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n) {
      R _ret=null;
      BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
      curBasicBlock = tmpBasicBlock;
      curProcedure.stmtLst.add(tmpBasicBlock);
      if(prevBlock != null){
		  tmpBasicBlock.predecessors.add(prevBlock);
		  prevBlock.successors.add(tmpBasicBlock);
	  }
      n.f0.accept(this);
      use = false;
      n.f1.accept(this);
      use = true;
      n.f2.accept(this);
      prevBlock = tmpBasicBlock;
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n) {
      R _ret=null;
      BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
      curBasicBlock = tmpBasicBlock;
      curProcedure.stmtLst.add(tmpBasicBlock);
      if(prevBlock != null){
		  tmpBasicBlock.predecessors.add(prevBlock);
		  prevBlock.successors.add(tmpBasicBlock);
	  }
      n.f0.accept(this);
      use = true;
      n.f1.accept(this);
      prevBlock = tmpBasicBlock;
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n) {
      R _ret=null;
      ++lineNum;
      prevBlock = curBasicBlock = null;
      n.f0.accept(this);
      BasicBlock tmpBasicBlock = new BasicBlock(lineNum);
      curBasicBlock = tmpBasicBlock;
      curProcedure.stmtLst.add(tmpBasicBlock);
      if(prevBlock != null){
		  tmpBasicBlock.predecessors.add(prevBlock);
		  prevBlock.successors.add(tmpBasicBlock);
	  }
      prevBlock = tmpBasicBlock;
      n.f1.accept(this);
      ++lineNum;
      n.f2.accept(this);
      use = true;
      ++lineNum;
      n.f3.accept(this);
      ++lineNum;
      n.f4.accept(this);
      prevBlock = curBasicBlock = null;
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n) {
      R _ret=null;
      n.f0.accept(this);
      curProcedure.hasCalls = true;
      use = true;
      n.f1.accept(this);
      n.f2.accept(this);
      use = true;
      n.f3.accept(this);
      if(curProcedure.maxCallArgs < n.f3.nodes.size())
    	  curProcedure.maxCallArgs = n.f3.nodes.size();
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n) {
      R _ret=null;
      n.f0.accept(this);
      use = true;
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n) {
      R _ret=null;
      n.f0.accept(this);
      use = true;
      n.f1.accept(this);
      use = true;
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "LT"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    */
   public R visit(Operator n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      TempClass tmpTemp;
      int num = Integer.parseInt(n.f1.f0.tokenImage);
      if(tempMap.containsKey(num))
    	  tmpTemp = tempMap.get(num);
      else{
    	  tmpTemp = new TempClass(num, curProcedure.name);
    	  tempMap.put(num, tmpTemp);
    	  tempSeen.add(tmpTemp);
      }
      if(use)
    	  curBasicBlock.use.add(tmpTemp);
      else
    	  curBasicBlock.def.add(tmpTemp);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n) {
      R _ret=null;
      n.f0.accept(this);
      label = n.f0.tokenImage;
      return _ret;
   }

}